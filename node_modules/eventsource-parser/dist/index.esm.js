function createParser(onParse) {
  let isFirstChunk, buffer, startingPosition, startingFieldLength, eventId, eventName, data;
  return reset(), { feed, reset };
  function reset() {
    isFirstChunk = !0, buffer = "", startingPosition = 0, startingFieldLength = -1, eventId = void 0, eventName = void 0, data = "";
  }
  function feed(chunk) {
    buffer = buffer ? buffer + chunk : chunk, isFirstChunk && hasBom(buffer) && (buffer = buffer.slice(BOM.length)), isFirstChunk = !1;
    const length = buffer.length;
    let position = 0, discardTrailingNewline = !1;
    for (; position < length; ) {
      discardTrailingNewline && (buffer[position] === `
` && ++position, discardTrailingNewline = !1);
      let lineLength = -1, fieldLength = startingFieldLength, character;
      for (let index = startingPosition; lineLength < 0 && index < length; ++index)
        character = buffer[index], character === ":" && fieldLength < 0 ? fieldLength = index - position : character === "\r" ? (discardTrailingNewline = !0, lineLength = index - position) : character === `
` && (lineLength = index - position);
      if (lineLength < 0) {
        startingPosition = length - position, startingFieldLength = fieldLength;
        break;
      } else
        startingPosition = 0, startingFieldLength = -1;
      parseEventStreamLine(buffer, position, fieldLength, lineLength), position += lineLength + 1;
    }
    position === length ? buffer = "" : position > 0 && (buffer = buffer.slice(position));
  }
  function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {
    if (lineLength === 0) {
      data.length > 0 && (onParse({
        type: "event",
        id: eventId,
        event: eventName || void 0,
        data: data.slice(0, -1)
        // remove trailing newline
      }), data = "", eventId = void 0), eventName = void 0;
      return;
    }
    const noValue = fieldLength < 0, field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));
    let step = 0;
    noValue ? step = lineLength : lineBuffer[index + fieldLength + 1] === " " ? step = fieldLength + 2 : step = fieldLength + 1;
    const position = index + step, valueLength = lineLength - step, value = lineBuffer.slice(position, position + valueLength).toString();
    if (field === "data")
      data += value ? `${value}
` : `
`;
    else if (field === "event")
      eventName = value;
    else if (field === "id" && !value.includes("\0"))
      eventId = value;
    else if (field === "retry") {
      const retry = parseInt(value, 10);
      Number.isNaN(retry) || onParse({ type: "reconnect-interval", value: retry });
    }
  }
}
const BOM = [239, 187, 191];
function hasBom(buffer) {
  return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);
}
export {
  createParser
};
//# sourceMappingURL=index.esm.js.map
