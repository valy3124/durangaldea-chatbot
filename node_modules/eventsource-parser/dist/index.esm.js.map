{"version":3,"file":"index.esm.js","sources":["../src/parse.ts"],"sourcesContent":["/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number,\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n"],"names":[],"mappings":"AAkBO,SAAS,aAAa,SAAsD;AAEjF,MAAI,cACA,QACA,kBACA,qBAGA,SACA,WACA;AAEE,SAAA,MAAA,GACC,EAAC,MAAM,MAAK;AAEnB,WAAS,QAAc;AACN,mBAAA,IACf,SAAS,IACT,mBAAmB,GACnB,sBAAsB,IAEtB,UAAU,QACV,YAAY,QACZ,OAAO;AAAA,EACT;AAEA,WAAS,KAAK,OAAqB;AACjC,aAAS,SAAS,SAAS,QAAQ,OAK/B,gBAAgB,OAAO,MAAM,MAC/B,SAAS,OAAO,MAAM,IAAI,MAAM,IAGlC,eAAe;AAGf,UAAM,SAAS,OAAO;AAClB,QAAA,WAAW,GACX,yBAAyB;AAG7B,WAAO,WAAW,UAAQ;AAMpB,iCACE,OAAO,QAAQ,MAAM;AAAA,KACvB,EAAE,UAEJ,yBAAyB;AAGvB,UAAA,aAAa,IACb,cAAc,qBACd;AAEJ,eAAS,QAAQ,kBAAkB,aAAa,KAAK,QAAQ,QAAQ,EAAE;AACrE,oBAAY,OAAO,KAAK,GACpB,cAAc,OAAO,cAAc,IACrC,cAAc,QAAQ,WACb,cAAc,QACvB,yBAAyB,IACzB,aAAa,QAAQ,YACZ,cAAc;AAAA,MACvB,aAAa,QAAQ;AAIzB,UAAI,aAAa,GAAG;AACC,2BAAA,SAAS,UAC5B,sBAAsB;AACtB;AAAA,MACF;AACE,2BAAmB,GACnB,sBAAsB;AAGxB,2BAAqB,QAAQ,UAAU,aAAa,UAAU,GAE9D,YAAY,aAAa;AAAA,IAC3B;AAEI,iBAAa,SAEf,SAAS,KACA,WAAW,MAGpB,SAAS,OAAO,MAAM,QAAQ;AAAA,EAElC;AAEA,WAAS,qBACP,YACA,OACA,aACA,YACA;AACA,QAAI,eAAe,GAAG;AAEhB,WAAK,SAAS,MAChB,QAAQ;AAAA,QACN,MAAM;AAAA,QACN,IAAI;AAAA,QACJ,OAAO,aAAa;AAAA,QACpB,MAAM,KAAK,MAAM,GAAG,EAAE;AAAA;AAAA,MAAA,CACvB,GAED,OAAO,IACP,UAAU,SAEZ,YAAY;AACZ;AAAA,IACF;AAEM,UAAA,UAAU,cAAc,GACxB,QAAQ,WAAW,MAAM,OAAO,SAAS,UAAU,aAAa,YAAY;AAClF,QAAI,OAAO;AAEP,cACF,OAAO,aACE,WAAW,QAAQ,cAAc,CAAC,MAAM,MACjD,OAAO,cAAc,IAErB,OAAO,cAAc;AAGvB,UAAM,WAAW,QAAQ,MACnB,cAAc,aAAa,MAC3B,QAAQ,WAAW,MAAM,UAAU,WAAW,WAAW,EAAE,SAAS;AAE1E,QAAI,UAAU;AACJ,cAAA,QAAQ,GAAG,KAAK;AAAA,IAAO;AAAA;AAAA,aACtB,UAAU;AACP,kBAAA;AAAA,aACH,UAAU,QAAQ,CAAC,MAAM,SAAS,IAAQ;AACzC,gBAAA;AAAA,aACD,UAAU,SAAS;AACtB,YAAA,QAAQ,SAAS,OAAO,EAAE;AAC3B,aAAO,MAAM,KAAK,KACrB,QAAQ,EAAC,MAAM,sBAAsB,OAAO,MAAA,CAAM;AAAA,IAEtD;AAAA,EACF;AACF;AAEA,MAAM,MAAM,CAAC,KAAK,KAAK,GAAG;AAE1B,SAAS,OAAO,QAAgB;AACvB,SAAA,IAAI,MAAM,CAAC,UAAkB,UAAkB,OAAO,WAAW,KAAK,MAAM,QAAQ;AAC7F;"}